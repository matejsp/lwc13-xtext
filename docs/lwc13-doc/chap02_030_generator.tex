\subsection{Code Generator}

In this section you will learn how to implement the code generator for 
the target application. For simplicity, the code generator templates are placed
in the \texttt{org.eclipse.xtext.example.ql} project in a sub-package \texttt{generator}. 
Usually it would be better to create a separate project which contains the generator,
since the language is independent from a single target platform. It would
be possible to create different code generators for different target platforms,
and it would be better to implement each of them as separate projects.

Generator templates in Xtend are implementations of the \texttt{IGenerator}
interface:

\begin{lstlisting}[language=Java]
package org.eclipse.xtext.generator;

public interface IGenerator {
	/**
	 * @param input - the input for which to generate resources
	 * @param fsa - file system access to be used to generate files
	 */
	public void doGenerate(Resource input, IFileSystemAccess fsa);
}
\end{lstlisting}

\subsubsection {Dispatcher template}
\label{sec:dispatcherTemplate}

The code generator is invoked with a \texttt{Resource} instance, which holds a \texttt{Questionnaire}
instance. We have to generate multiple artifacts for each resource, so it is a common 
pattern to create a template class which serves as entry point and dispatches to other
template classes to create the artifacts. Usually one template per artifact is
created.

Create the class \texttt{Root.java} in 
package \texttt{org.eclipse.xtext.example.ql.generator}:

\begin{lstlisting}[language=Java]
package org.eclipse.xtext.example.ql.generator;

import javax.inject.Inject;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.compiler.JvmModelGenerator;

@SuppressWarnings("restriction")
public class Root implements IGenerator {
  @Inject
  JvmModelGenerator jvmModelGenerator;

  public void doGenerate(Resource input, IFileSystemAccess fsa) {
    // dispatch to other generators
    jvmModelGenerator.doGenerate(input, fsa);
  }
}
\end{lstlisting}

As a first generator to which is dispatched, we inject an instance of
\texttt{JvmModelGenerator}. This is a standard generator shipped with Xtext which
translates types inferred by the Jvm Model Inferrer to Java classes.
In our case, the Java class for Forms are generated by the
\texttt{JvmModelGenerator}. In JSF terms, we speek of the \emph{Backing Bean}.
 
Next, Xtext has to know that \texttt{Root} is the template that has to be invoked
as generator implementation. This has to be configured - you guessed right! - 
with Guice again. We need to add a configuration that binds the \texttt{IGenerator}
interface to the \texttt{Root} class.

Open class \texttt{QlDslRuntimeModule} and add this method:

\begin{lstlisting}[language=Java]
  @Override
  public Class<? extends IGenerator> bindIGenerator() {
    return Root.class;
  }
\end{lstlisting}

Now we are ready to add additional templates and register them in the
\texttt{Root} class.

\subsubsection{OutputConfigurationProvider}
\label{sec:outputConfigurationProvider}

In JSF applications all the web related content is normally placed under
\texttt{./WebContent} instead of \texttt{./src-gen} which is mostly used in
java applications. We will adapt to this convention and seperate generated java
classes and jsf artifacts from each other. For that purpose add a class called
\texttt{JsfOutputConfigurationProvider} derived from
\texttt{OutputConfigurationProvider}
\footnote{\url{http://xtextcasts.org/episodes/15-output-configurations}} which
adds an additional \texttt{OutputConfiguration} pointing to the ouput directoy
\texttt{./WebContent} as shown in the listing below.

\begin{lstlisting}[language=Java]
package org.eclipse.xtext.example.ql.generator;

import java.util.Set;

import org.eclipse.xtext.generator.OutputConfiguration;
import org.eclipse.xtext.generator.OutputConfigurationProvider;

public class JsfOutputConfigurationProvider extends OutputConfigurationProvider {

  public final String WEB_CONTENT = "WebContent";

  /**
   * @return a set of {@link OutputConfiguration} available for the generator
   */
  public Set<OutputConfiguration> getOutputConfigurations() {
    Set<OutputConfiguration> outputConfigurations = super
        .getOutputConfigurations();

    OutputConfiguration webContent = new OutputConfiguration(WEB_CONTENT);
    webContent.setDescription("Read-only Output Folder for forms");
    webContent.setOutputDirectory("./WebContent");
    webContent.setOverrideExistingResources(true);
    webContent.setCreateOutputDirectory(true);
    webContent.setCleanUpDerivedResources(true);
    webContent.setSetDerivedProperty(true);
    outputConfigurations.add(webContent);

    return outputConfigurations;
  }
}
\end{lstlisting}

Our \texttt{JsfOutputConfigurationProvider} has to be bound to the
\texttt{QlDslRuntimeModule} by overriding the method \texttt{configure}. 

\begin{lstlisting}[language=Java]
@Override public void configure(Binder binder) {
    super.configure(binder);
    binder.bind(IOutputConfigurationProvider.class)
        .to(JSFOutputConfigurationProvider.class).in(Singleton.class);
  }
 \end{lstlisting}
 
After
this step we can refer to the additional \texttt{OutputConfiguration} in
generators by use of the constant \texttt{WEB\_CONTENT} defined in class
\texttt{JsfOutputConfigurationProvider}.

\subsubsection {JSF Generator}
\label{sec:jsfGenerator}

After creation of the class \texttt{Root} in section
\ref{sec:dispatcherTemplate} \texttt{Dispatcher Template} where we easily can
add new Generators and the defintion of the
\texttt{JsfOutputConfigurationProvider} in section \ref{sec:outputConfigurationProvider}
\texttt{OutputConfigurationProvider} which prvides an output folder for JSF
artifacts, we use the \emph{New Xtend Class Wizard} to create a new Xtend class
called \texttt{JSFGenerator.xtend} in package \texttt{org.eclipse.xtext.example.ql.generator}.

This class will be our entry point to generate JSF related artifacts. The
\emph{New Xtend Class Wizard} provides the possibility to bind interfaces to the
new class by use of the \texttt{Add} button near the interface section.

\begin{center}
\includegraphics[width=8cm]{./images/chapter02/newXtendClassWizard.png}
\end{center}

As we want to create a new generator we add the interface
\texttt{org.eclipse.xtext.generator.IGenerator} to our new Xtend class.
After typing in the package, the name and the interface of our new Xtend class
as shown in the figure above, we can finish the
wizard so that the class shown in the following listing
will be created in our project.

\begin{lstlisting}[language=Java] 
package org.eclipse.xtext.example.ql.generator

import org.eclipse.xtext.generator.IGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess

class JSFGenerator implements IGenerator {
	
	override doGenerate(Resource input, IFileSystemAccess fsa) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
}
\end{lstlisting}

To get the created \texttt{JSFGenarator} executed we have to inject and dispatch
to it in our dispatcher template \texttt{Root.class}
which was created in section \ref{sec:dispatcherTemplate}
\texttt{Dispatcher Template} earlier.

\begin{lstlisting}[language=Java] 
 package org.eclipse.xtext.example.ql.generator;

import javax.inject.Inject;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.compiler.JvmModelGenerator;

public class Root implements IGenerator {
  @Inject
  JvmModelGenerator jvmModelGenerator;
  @Inject
  JSFGenerator jsfGenerator;

  public void doGenerate(Resource input, IFileSystemAccess fsa) {
    // dispatch to other generators
    jvmModelGenerator.doGenerate(input, fsa);
    jsfGenerator.doGenerate(input, fsa);
  }
}
\end{lstlisting}


- show whole generater
- explain step by step