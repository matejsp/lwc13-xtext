\subsection{Code Generator}

In this section you will learn how to implement the code generator for 
the target application. For simplicity the code generator templates are placed in the
org.eclipse.xtext.example.ql project in a sub-package generator. 
Usually it would be better to create a separate project which contains the generator,
since the language is independent from a single target platform. It would
be possible to create different code generators for different target platforms,
and it would be better to implement each of them as separate projects.

Generator templates in Xtend are implementations of the org.eclipse.xtext.generator.IGenerator
interface:

\begin{lstlisting}[language=Java]
public interface IGenerator {
	/**
	 * @param input - the input for which to generate resources
	 * @param fsa - file system access to be used to generate files
	 */
	public void doGenerate(Resource input, IFileSystemAccess fsa);
}
\end{lstlisting}

\subsubsection {Dispatcher template}

The code generator is invoked with a Resource instance, which holds a Questionnaire
instance. We have to generate multiple artifacts for each resource, so it is a common 
pattern to create a template class serves as entry point and dispatches to other
template classes to create the artifacts. Usually one template per artifact is
created.

Create the class Root.java in package org.eclipse.xtext.example.ql.generator:

\begin{lstlisting}[language=Java]
package org.eclipse.xtext.example.ql.generator;

import javax.inject.Inject;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.compiler.JvmModelGenerator;

@SuppressWarnings("restriction")
public class Root implements IGenerator {
  @Inject
  JvmModelGenerator jvmModelGenerator;

  public void doGenerate(Resource input, IFileSystemAccess fsa) {
    // dispatch to other generators
    jvmModelGenerator.doGenerate(input, fsa);
  }
}
\end{lstlisting}

As a first generator to which a dispatch, we inject an instance of
JvmModelGenerator. This is a standard generator shipped with Xtext which
translates types inferred by the Jvm Model Inferrer to Java classes.
In our case, the Java Bean class for Forms are generated by the
JvmModelGenerator. 
 
Next, Xtext has to know that Root.java is the template that has to be invoked
as generator implementation. This has to be configured - you guessed right! - 
with Guice again. We need to add a configuration that binds the IGenerator
interface to the Root class.

Open class QlDslRuntimeModule and add this method:

\begin{lstlisting}[language=Java]
  @Override
  public Class<? extends IGenerator> bindIGenerator() {
    return Root.class;
  }
\end{lstlisting}

Now we are ready to add templates additional templates and register them in the
Root class.
